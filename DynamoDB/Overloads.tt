// Copyright 2015 Adamantworks.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	var itemKey = Param("ItemKey","key");
	var projection = Param("ProjectionExpression","projection","null");
	var consistent = Param("bool","consistent","false");
	var cancellationToken = Param("CancellationToken", "cancellationToken","CancellationToken.None");
	var hashKeyOnly = ParamTransform("DynamoDBKeyValue", "hashKey", "new ItemKey(hashKey)");
	var hashKeySkipped = ParamTransform("DynamoDBKeyValue", "hashKey", null);
	var rangeKey = ParamTransform("DynamoDBKeyValue", "rangeKey","new ItemKey(hashKey, rangeKey)");
	var status = Param("TableStatus","status");
	var timeout = Param("TimeSpan", "timeout");
	var provisionedThroughput = ParamTransform("ProvisionedThroughput", "provisionedThroughput","(ProvisionedThroughput?)provisionedThroughput", "null");
	var indexProvisionedThroughputs = Param("IReadOnlyDictionary<string, ProvisionedThroughput>", "indexProvisionedThroughputs", "null");
	var keysAsync = Param("IAsyncEnumerable<ItemKey>", "keys");
	var keysSyncToAsync = ParamTransform("IEnumerable<ItemKey>", "keys", "keys.ToAsyncEnumerable()");
	var keys = Param("IEnumerable<ItemKey>", "keys");
	var readAhead = Param("ReadAhead", "readAhead", "ReadAhead.Some");
	var outerItemsAsync = Param("IAsyncEnumerable<T>", "outerItems");
	var outerItemsSyncToAsync = ParamTransform("IEnumerable<T>", "outerItems", "outerItems.ToAsyncEnumerable()");
	var outerItemsSync = Param("IEnumerable<T>", "outerItems");
	var keySelector = Param("Func<T, ItemKey>","keySelector");
	var resultSelector = Param("Func<T, DynamoDBMap, TResult>", "resultSelector");
	var item = Param("DynamoDBMap", "item");
	var condition = Param("PredicateExpression", "condition", "null");
	var values = Param("Values", "values", "null");
	var returnOldItem = Param("bool", "returnOldItem", "false");
	var updateExp  = Param("UpdateExpression", "update");
	var updateReturnValue = Param("UpdateReturnValue", "returnValue", "UpdateReturnValue.None");
	var regionArg = Argument("Region");
	var tableNameArg = Argument("Name");
	var indexNameNoneArg = Argument("null");
	var keySchemaArg = Argument("Schema.Key");
	var hashKey = Param("DynamoDBKeyValue", "hashKey");
	var filter = Param("PredicateExpression", "filter", "null");
	var tableName = Param("string", "tableName");
	var schema = Param("TableSchema", "schema");

	Func<IReadOnlyList<Parameter>, bool> noValuesWithoutFilter = overload => !(overload.Contains(values) && !overload.Contains(filter));
	Func<IReadOnlyList<Parameter>, bool> noValuesWithoutCondition = overload => !(overload.Contains(values) && !overload.Contains(condition));

	// Region
	var listTablesAsync = new Method("IAsyncEnumerable<string>", "ListTablesAsync", GenOverloads(readAhead));
	var createTableAsync = new Method("Task<ITable>", "CreateTableAsync",
		GenOverloads(true, tableName, schema, provisionedThroughput, indexProvisionedThroughputs, cancellationToken));
	var createTable = new Method("ITable", "CreateTable",
		GenOverloads(true, tableName, schema, provisionedThroughput, indexProvisionedThroughputs));

	// Table
	var reloadAsync = new Method("Task", "ReloadAsync", GenOverloads(cancellationToken));
	var waitUntilNotAsync = new Method("Task", "WaitUntilNotAsync",
		GenOverloads(status, cancellationToken)
		.Concat(GenOverloads(status, timeout, cancellationToken)));
	var updateTableAsync = new Method("Task", "UpdateTableAsync",
		GenOverloads(true, provisionedThroughput, indexProvisionedThroughputs, cancellationToken)
		// must pass either provisionedThroughput or indexProvisionedThroughputs
		.Where(overload => overload.Contains(provisionedThroughput) || overload.Contains(indexProvisionedThroughputs)));
	var updateTable = new Method("void", "UpdateTable",
		GenOverloads(true, provisionedThroughput, indexProvisionedThroughputs)
		// must pass either provisionedThroughput or indexProvisionedThroughputs
		.Where(overload => overload.Contains(provisionedThroughput) || overload.Contains(indexProvisionedThroughputs)));
	var getAsync = new Method("Task<DynamoDBMap>", "GetAsync",
		GenOverloads(true, hashKeyOnly, projection, consistent, cancellationToken)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, projection, consistent, cancellationToken))
		.Concat(GenOverloads(itemKey, projection, consistent, cancellationToken)));
	var get = new Method("DynamoDBMap", "Get",
		GenOverloads(true, hashKeyOnly, projection, consistent)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, projection, consistent))
		.Concat(GenOverloads(itemKey, projection, consistent)));
	var batchGetAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "BatchGetAsync",
		GenOverloads(true, keysSyncToAsync, projection, consistent, readAhead)
		.Concat(GenOverloads(keysAsync, projection, consistent, readAhead)));
	var batchGet = new Method("IEnumerable<DynamoDBMap>", "BatchGet",
		GenOverloads(keys, projection, consistent));
	var batchGetJoinAsync = new Method("IAsyncEnumerable<TResult>", "BatchGetJoinAsync<T, TResult>",
		GenOverloads(true, outerItemsSyncToAsync, keySelector, resultSelector, projection, consistent, readAhead)
		.Concat(GenOverloads(outerItemsAsync, keySelector, resultSelector, projection, consistent, readAhead)));
	var batchGetJoin = new Method("IEnumerable<TResult>", "BatchGetJoin<T, TResult>",
		GenOverloads(outerItemsSync, keySelector, resultSelector, projection, consistent));
	var putAsync = new Method("Task<DynamoDBMap>", "PutAsync",
		GenOverloads(item, condition, values, returnOldItem, cancellationToken)
		// Can't have values without condition
		.Where(noValuesWithoutCondition));
	var put = new Method("DynamoDBMap", "Put",
		GenOverloads(item, condition, values, returnOldItem)
		// Can't have values without condition
		.Where(noValuesWithoutCondition));
	var updateAsync = new Method("Task<DynamoDBMap>", "UpdateAsync",
		GenOverloads(true, hashKeyOnly, updateExp, condition, values, updateReturnValue, cancellationToken)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, updateExp, condition, values, updateReturnValue, cancellationToken))
		.Concat(GenOverloads(itemKey, updateExp, condition, values, updateReturnValue, cancellationToken)));
	var update = new Method("DynamoDBMap", "Update",
		GenOverloads(true, hashKeyOnly, updateExp, condition, values, updateReturnValue)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, updateExp, condition, values, updateReturnValue))
		.Concat(GenOverloads(itemKey, updateExp, condition, values, updateReturnValue)));
	var tryUpdateAsync = new Method("Task<bool>", "TryUpdateAsync",
		GenOverloads(true, hashKeyOnly, updateExp, condition, values, cancellationToken)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, updateExp, condition, values, cancellationToken))
		.Concat(GenOverloads(itemKey, updateExp, condition, values, cancellationToken)));
	var tryUpdate = new Method("bool", "TryUpdate",
		GenOverloads(true, hashKeyOnly, updateExp, condition, values)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, updateExp, condition, values))
		.Concat(GenOverloads(itemKey, updateExp, condition, values)));
	var deleteAsync = new Method("Task<DynamoDBMap>", "DeleteAsync",
		GenOverloads(true, hashKeyOnly, condition, values, returnOldItem, cancellationToken)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, condition, values, returnOldItem, cancellationToken))
		.Concat(GenOverloads(itemKey, condition, values, returnOldItem, cancellationToken))
		// Can't have values without condition
		.Where(noValuesWithoutCondition));
	var delete = new Method("DynamoDBMap", "Delete",
		GenOverloads(true, hashKeyOnly, condition, values, returnOldItem)
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey, condition, values, returnOldItem))
		.Concat(GenOverloads(itemKey, condition, values, returnOldItem))
		// Can't have values without condition
		.Where(noValuesWithoutCondition));
	var query = new Method("IQueryContext", "Query", "new QueryContext",
		GenOverloads(true, regionArg, tableNameArg, indexNameNoneArg, keySchemaArg, hashKey, projection, filter, values, consistent)
		.Where(noValuesWithoutFilter));
	var scan = new Method("IScanContext", "Scan", "new ScanContext",
		GenOverloads(true, regionArg, tableNameArg, projection, filter, values)
		.Where(noValuesWithoutFilter));
#>
using Adamantworks.Amazon.DynamoDB.DynamoDBValues;
using Adamantworks.Amazon.DynamoDB.Schema;
using Adamantworks.Amazon.DynamoDB.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Adamantworks.Amazon.DynamoDB
{
	public partial interface IDynamoDBRegion
	{
<#		GenInterface(listTablesAsync); #>

<#		GenInterface(createTableAsync); #>
<#		GenInterface(createTable); #>
	}

	internal partial class Region
	{
<#		GenMethods(listTablesAsync); #>

<#		GenMethods(createTableAsync); #>

<#		GenMethods(createTable); #>
	}

	public partial interface ITable
	{
<#		GenInterface(reloadAsync); #>

<#		GenInterface(waitUntilNotAsync); #>

<#		GenInterface(updateTableAsync); #>
<#		GenInterface(updateTable); #>

<#		GenInterface(getAsync); #>
<#		GenInterface(get); #>

<#		GenInterface(batchGetAsync); #>
<#		GenInterface(batchGet); #>

<#		GenInterface(batchGetJoinAsync); #>
<#		GenInterface(batchGetJoin); #>

<#		GenInterface(putAsync); #>
<#		GenInterface(put); #>

<#		GenInterface(updateAsync); #>
<#		GenInterface(update); #>

<#		GenInterface(tryUpdateAsync); #>
<#		GenInterface(tryUpdate); #>

<#		GenInterface(deleteAsync); #>
<#		GenInterface(delete); #>

<#		GenInterface(query); #>

<#		GenInterface(scan); #>
	}

	internal partial class Table
	{
<#		GenMethods(reloadAsync); #>

<#		GenMethods(waitUntilNotAsync); #>

<#		GenMethods(updateTableAsync); #>

<#		GenMethods(updateTable); #>

<#		GenMethods(getAsync); #>

<#		GenMethods(get); #>

<#		GenMethods(batchGetAsync); #>

<#		GenMethods(batchGet); #>

<#		GenMethods(batchGetJoinAsync); #>

<#		GenMethods(batchGetJoin); #>

<#		GenMethods(putAsync); #>

<#		GenMethods(put); #>

<#		GenMethods(updateAsync); #>

<#		GenMethods(update); #>

<#		GenMethods(tryUpdateAsync); #>

<#		GenMethods(tryUpdate); #>

<#		GenMethods(deleteAsync); #>

<#		GenMethods(delete); #>

<#		GenMethods(query); #>

<#		GenMethods(scan); #>
	}
}
<#+
	public Parameter Param(string type, string name)
	{
		return new Parameter(type, name, null, name);
	}
	public Parameter Param(string type, string name, string defaultValue)
	{
		return new Parameter(type, name, defaultValue, name);
	}
	public Parameter ParamTransform(string type, string name, string value)
	{
		return new Parameter(type, name, null, value);
	}
	public Parameter ParamTransform(string type, string name, string value, string defaultValue)
	{
		return new Parameter(type, name, defaultValue, value);
	}
	public Parameter Argument(string value)
	{
		return new Parameter(null, null, null, value);
	}

	public IEnumerable<IReadOnlyList<Parameter>> GenOverloads(params Parameter[] parameters)
	{
		return GenOverloads(false, parameters);
	}

	public IEnumerable<IReadOnlyList<Parameter>> GenOverloads(bool includeAll, params Parameter[] parameters)
	{
		var paramsList = parameters.ToList();
		var overloads = new List<List<Parameter>>();
		overloads.Add(new List<Parameter>());
		foreach(var param in parameters)
		{
			// params that exist only to pass values, or aren't optional, we tack onto all overloads
			if(param.Name == null || param.DefaultValue == null)
			{
				foreach(var overload in overloads)
					overload.Add(param);
			}
			else
			{
				var ovarloadsWithParam = overloads.Select(o =>
					{
						var overload = new List<Parameter>(o);
						overload.Add(param);
						return overload;
					}).ToList(); // So we gen them before changing overloads

				// overloads without the param need the default value
				foreach(var overload in overloads)
					overload.Add(param.Default);

				overloads.AddRange(ovarloadsWithParam);
			}
		}
		if(!includeAll)
			overloads.RemoveAt(overloads.Count-1); // The last one has no defaults
		return overloads;
	}

	public void GenInterface(Method method)
	{
		foreach(var overload in method.ParameterOverloads)
		{
			#>		<#+
			GenDeclaration(method, overload);
			#>;
<#+
		}
	}

	public void GenMethods(Method method)
	{
#>		#region <#= method.Name #>
<#+		foreach(var overload in method.ParameterOverloads)
		{
#>		public <#+ GenDeclaration(method, overload); #>

		{
			<#+if(method.ReturnType != "void")
				#>return <#+
			#><#= method.Call #>(<#+
			var firstParam = true;
			foreach(var param in overload)
				if(param.Value != null)
				{
					if(firstParam)
						firstParam = false;
					else
						#>, <#+
					#><#= param.Value #><#+
				}
			#>);
		}
<#+
		}
#>		#endregion
<#+
	}

	public void GenDeclaration(Method method, IReadOnlyList<Parameter> overload)
	{
		#><#= method.ReturnType #> <#= method.Name #>(<#+
		var firstParam = true;
		foreach(var param in overload)
			if(param.Name != null)
			{
				if(firstParam)
					firstParam = false;
				else
					#>, <#+
				#><#= param.Type #> <#= param.Name #><#+
			}
		#>)<#+
	}

	public class Method
	{
		public readonly string ReturnType;
		public readonly string Name;
		public readonly string Call;
		public readonly IReadOnlyList<IReadOnlyList<Parameter>> ParameterOverloads;

		public Method(string returnType, string name, IEnumerable<IReadOnlyList<Parameter>> parameterOverloads)
			: this(returnType, name, name, parameterOverloads)
		{
		}

		public Method(string returnType, string name, string call, IEnumerable<IReadOnlyList<Parameter>> parameterOverloads)
		{
			ReturnType = returnType;
			Name = name;
			Call = call;
			ParameterOverloads = parameterOverloads.ToList();
		}
	}

	public class Parameter
	{
		public readonly string Type;
		public readonly string Name;
		public readonly string DefaultValue;
		public readonly string Value;
		public readonly Parameter Default;

		public Parameter(string type, string name, string defaultValue, string value)
		{
			Type = type;
			Name = name;
			DefaultValue = defaultValue;
			Value = value;
			if(name != null)
				Default = new Parameter(null, null, null, defaultValue ?? value);
		}
	}
#>
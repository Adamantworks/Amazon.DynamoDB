// Copyright 2015 Adamantworks.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	var itemKey = Param("ItemKey","key");
	var projection = Param("ProjectionExpression", "projection", "null");
	var consistent = Param("bool","consistent","false");
	var cancellationToken = Param("CancellationToken", "cancellationToken","CancellationToken.None");
	var hashKeyOnly = ParamTransform("DynamoDBKeyValue", "hashKey", "ItemKey.Create(hashKey)");
	var hashKeyObjectOnly = ParamTransform("object", "hashKey", "ItemKey.Create(hashKey)");
	var hashKeySkipped = ParamTransform("DynamoDBKeyValue", "hashKey", null);
	var hashKeyObjectSkipped = ParamTransform("object", "hashKey", null);
	var rangeKey = ParamTransform("DynamoDBKeyValue", "rangeKey", "ItemKey.Create(hashKey, rangeKey)");
	var rangeKeyObject = ParamTransform("object", "rangeKey", "ItemKey.Create(hashKey, rangeKey)");
	var rangeKeySkipped = ParamTransform("DynamoDBKeyValue", "rangeKey", null);
	var rangeKeyObjectSkipped = ParamTransform("object", "rangeKey", null);
	var converterHash = ParamTransform("IValueConverter", "converter", "ItemKey.Create(hashKey, converter)");
	var converterHashAndRange = ParamTransform("IValueConverter", "converter", "ItemKey.Create(hashKey, rangeKey, converter)");
	var status = Param("CollectionStatus","status");
	var timeout = Param("TimeSpan", "timeout");
	var provisionedThroughput = ParamTransform("ProvisionedThroughput", "provisionedThroughput","(ProvisionedThroughput?)provisionedThroughput", "null");
	var indexProvisionedThroughputs = Param("IReadOnlyDictionary<string, ProvisionedThroughput>", "indexProvisionedThroughputs", "null");
	var keysAsync = Param("IAsyncEnumerable<ItemKey>", "keys");
	var keysSyncToAsync = ParamTransform("IEnumerable<ItemKey>", "keys", "keys.ToAsyncEnumerable()");
	var keys = Param("IEnumerable<ItemKey>", "keys");
	var tableNamePrefix = Param("string", "tableNamePrefix");
	var readAhead = Param("ReadAhead", "readAhead", "ReadAhead.Some");
	var outerItemsAsync = Param("IAsyncEnumerable<T>", "outerItems");
	var outerItemsSyncToAsync = ParamTransform("IEnumerable<T>", "outerItems", "outerItems.ToAsyncEnumerable()");
	var outerItemsSync = Param("IEnumerable<T>", "outerItems");
	var keySelector = Param("Func<T, ItemKey>","keySelector");
	var resultSelector = Param("Func<T, DynamoDBMap, TResult>", "resultSelector");
	var item = Param("DynamoDBMap", "item");
	var values = Param("Values", "values", "null");
	var returnOldItem = Param("bool", "returnOldItem", "false");
	var updateExp  = Param("UpdateExpression", "update");
	var updateReturnValue = Param("UpdateReturnValue", "returnValue", "UpdateReturnValue.None");
	var indexTableArg = Argument("Table");
	var indexNoneArg = Argument("null");
	var tableArg = Argument("table");
	var indexDotTableArg = Argument("index.Table");
	var indexArg = Argument("index");
	var projectionNoneArg = Argument("null");
	var projectionArg = Argument("projection");
	var consistentNoneArg = Argument("false");
	var consistentArg = Argument("consistentRead ?? false");
	var hashKey = Param("DynamoDBKeyValue", "hashKey");
	var hashKeyObject = ParamTransform("object", "hashKey", "DynamoDBKeyValue.Convert(hashKey)");
	var hashKeyObjectConverter = ParamTransform("object", "hashKey", "DynamoDBKeyValue.Convert(hashKey, converter)");
	var converterSkipped = ParamTransform("IValueConverter", "converter", null);
	var filter = Param("PredicateExpression", "filter", "null");
	var tableName = Param("string", "tableName");
	var schema = Param("TableSchema", "schema");
	var thisArg = Argument("this");
	var rangeKeyOnly = Param("DynamoDBKeyValue", "rangeKey");
	var rangeKeyOnlyObject = ParamTransform("object", "rangeKey", "DynamoDBKeyValue.Convert(rangeKey)");
	var rangeKeyOnlyObjectConverter = ParamTransform("object", "rangeKey", "DynamoDBKeyValue.Convert(rangeKey, converter)");
	var batchWrite = Param("IBatchWrite", "batch");
	var batchWriteAsync = Param("IBatchWriteAsync", "batch");
	var segment = Param("int", "segment");
	var totalSegments = Param("int", "totalSegments");

	Func<IReadOnlyList<Parameter>, bool> noIndexThroughputWithoutTableThroughput = overload => !(overload.Contains(indexProvisionedThroughputs) && ! overload.Contains(provisionedThroughput));
	Func<IReadOnlyList<Parameter>, bool> noValuesWithoutFilter = overload => !(overload.Contains(values) && !overload.Contains(filter));

	var keyOverloads = GenOverloads(true, hashKeyOnly)
		.Concat(GenOverloads(true, hashKeySkipped, converterHash))
		.Concat(GenOverloads(true, hashKeyObjectOnly))
		.Concat(GenOverloads(true, hashKeyObjectSkipped, converterHash))
		.Concat(GenOverloads(true, hashKeySkipped, rangeKey))
		.Concat(GenOverloads(true, hashKeySkipped, rangeKeySkipped, converterHashAndRange))
		.Concat(GenOverloads(true, hashKeyObjectSkipped, rangeKey))
		.Concat(GenOverloads(true, hashKeyObjectSkipped, rangeKeySkipped, converterHashAndRange))
		.Concat(GenOverloads(true, hashKeySkipped, rangeKeyObject))
		.Concat(GenOverloads(true, hashKeySkipped, rangeKeyObjectSkipped, converterHashAndRange))
		.Concat(GenOverloads(true, hashKeyObjectSkipped, rangeKeyObject))
		.Concat(GenOverloads(true, hashKeyObjectSkipped, rangeKeyObjectSkipped, converterHashAndRange))
		.Concat(GenOverloads(true, itemKey))
		.ToList();

	var rangeKeyOverloads =
		GenOverloads(true, rangeKeyOnlyObjectConverter, converterSkipped)
		.Concat(GenOverloads(true, rangeKeyOnlyObject))
		.Concat(GenOverloads(true, rangeKeyOnly, converterSkipped))
		.Concat(GenOverloads(true, rangeKeyOnly))
		.ToList();

	var startInclusive = Param("DynamoDBKeyValue", "startInclusive");
	var startInclusiveObject = ParamTransform("object", "startInclusive", "DynamoDBKeyValue.Convert(startInclusive)");
	var startInclusiveObjectConverter = ParamTransform("object", "startInclusive", "DynamoDBKeyValue.Convert(startInclusive, converter)");
	var endExclusive = Param("DynamoDBKeyValue", "endExclusive");
	var endExclusiveObject = ParamTransform("object", "endExclusive", "DynamoDBKeyValue.Convert(endExclusive)");
	var endExclusiveObjectConverter = ParamTransform("object", "endExclusive", "DynamoDBKeyValue.Convert(endExclusive, converter)");
	var rangeKeyBetweenOverloads =
		GenOverloads(true, startInclusiveObjectConverter, endExclusiveObjectConverter, converterSkipped)
		.Concat(GenOverloads(true, startInclusiveObject, endExclusiveObject))
		.Concat(GenOverloads(true, startInclusiveObjectConverter, endExclusive, converterSkipped))
		.Concat(GenOverloads(true, startInclusiveObject, endExclusive))
		.Concat(GenOverloads(true, startInclusive, endExclusiveObjectConverter, converterSkipped))
		.Concat(GenOverloads(true, startInclusive, endExclusiveObject))
		.Concat(GenOverloads(true, startInclusive, endExclusive, converterSkipped))
		.Concat(GenOverloads(true, startInclusive, endExclusive))
		.ToList();

	// Region
	var listTablesAsync = new Method("IAsyncEnumerable<string>", "ListTablesAsync", GenOverloads(readAhead));
	var listTablesWithPrefixAsync = new Method("IAsyncEnumerable<string>", "ListTablesWithPrefixAsync", GenOverloads(tableNamePrefix, readAhead));
	var createTableAsync = new Method("Task<ITable>", "CreateTableAsync",
		GenOverloads(true, tableName, schema, provisionedThroughput, indexProvisionedThroughputs, cancellationToken)
		.Where(noIndexThroughputWithoutTableThroughput));
	var createTable = new Method("ITable", "CreateTable",
		GenOverloads(true, tableName, schema, provisionedThroughput, indexProvisionedThroughputs)
		.Where(noIndexThroughputWithoutTableThroughput));

	// Table
	var reloadAsync = new Method("Task", "ReloadAsync", GenOverloads(cancellationToken));
	var waitUntilNotAsync = new Method("Task", "WaitUntilNotAsync",
		GenOverloads(status, cancellationToken)
		.Concat(GenOverloads(status, timeout, cancellationToken)));
	var updateTableAsync = new Method("Task", "UpdateTableAsync",
		GenOverloads(true, provisionedThroughput, indexProvisionedThroughputs, cancellationToken)
		// must pass either provisionedThroughput or indexProvisionedThroughputs
		.Where(overload => overload.Contains(provisionedThroughput) || overload.Contains(indexProvisionedThroughputs)));
	var updateTable = new Method("void", "UpdateTable",
		GenOverloads(true, provisionedThroughput, indexProvisionedThroughputs)
		// must pass either provisionedThroughput or indexProvisionedThroughputs
		.Where(overload => overload.Contains(provisionedThroughput) || overload.Contains(indexProvisionedThroughputs)));
	var getAsyncForwards = new Method("Task<DynamoDBMap>", "GetAsync", "eventuallyConsistentContext.GetAsync",
		GenOverloads(true, keyOverloads, cancellationToken));
	var getForwards = new Method("DynamoDBMap", "Get", "eventuallyConsistentContext.Get", keyOverloads);
	var batchGetAsyncForwards = new Method("IAsyncEnumerable<DynamoDBMap>", "BatchGetAsync", "eventuallyConsistentContext.BatchGetAsync",
		GenOverloads(true, keysSyncToAsync, readAhead)
		.Concat(GenOverloads(true, keysAsync, readAhead)));
	var batchGetForwards = new Method("IEnumerable<DynamoDBMap>", "BatchGet", "eventuallyConsistentContext.BatchGet",
		GenOverloads(true, keys));
	var batchGetJoinAsyncForwards = new Method("IAsyncEnumerable<TResult>", "BatchGetJoinAsync<T, TResult>", "eventuallyConsistentContext.BatchGetJoinAsync",
		GenOverloads(true, outerItemsSyncToAsync, keySelector, resultSelector, readAhead)
		.Concat(GenOverloads(true, outerItemsAsync, keySelector, resultSelector, readAhead)));
	var batchGetJoinForwards = new Method("IEnumerable<TResult>", "BatchGetJoin<T, TResult>", "eventuallyConsistentContext.BatchGetJoin",
		GenOverloads(true, outerItemsSync, keySelector, resultSelector));
	var forKey = new Method("IIfSyntax", "ForKey", "new ModifyContext", GenOverloads(true, thisArg,  keyOverloads));
	var putAsyncForwards = new Method("Task<DynamoDBMap>", "PutAsync", "putContext.PutAsync",
		GenOverloads(true, item, returnOldItem, cancellationToken));
	var putForwards = new Method("DynamoDBMap", "Put", "putContext.Put",
		GenOverloads(true, item, returnOldItem));
	var queryForwards = new Method("IReverseSyntax", "Query", "new QueryContext",
		GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKey, filter, values)
		.Concat(GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKey, converterSkipped, filter, values))
		.Concat(GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKeyObject, filter, values))
		.Concat(GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var scanForwards = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, filter, values)
		.Where(noValuesWithoutFilter));
	var indexQueryForwards = new Method("IReverseSyntax", "Query", "new QueryContext",
		GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKey, filter, values)
		.Concat(GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKey, converterSkipped, filter, values))
		.Concat(GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKeyObject, filter, values))
		.Concat(GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var indexScanForwards = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, filter, values)
		.Where(noValuesWithoutFilter));
	var batchDelete = new Method("void", "Delete",
			GenOverloads(false, batchWrite, keyOverloads));
	var batchDeleteAsync = new Method("void", "Delete",
			GenOverloads(false, batchWriteAsync, keyOverloads));

	// Syntax
	var getAsync = new Method("Task<DynamoDBMap>", "GetAsync",
		GenOverloads(false, keyOverloads, cancellationToken));
	var get = new Method("DynamoDBMap", "Get",
		GenOverloads(false, keyOverloads));
	var batchGetAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "BatchGetAsync",
		GenOverloads(true, keysSyncToAsync, readAhead)
		.Concat(GenOverloads(keysAsync, readAhead)));
	var batchGet = new Method("IEnumerable<DynamoDBMap>", "BatchGet",
		GenOverloads(keys));
	var batchGetJoinAsync = new Method("IAsyncEnumerable<TResult>", "BatchGetJoinAsync<T, TResult>",
		GenOverloads(true, outerItemsSyncToAsync, keySelector, resultSelector, readAhead)
		.Concat(GenOverloads(outerItemsAsync, keySelector, resultSelector, readAhead)));
	var batchGetJoin = new Method("IEnumerable<TResult>", "BatchGetJoin<T, TResult>",
		GenOverloads(outerItemsSync, keySelector, resultSelector));
	var putAsync = new Method("Task<DynamoDBMap>", "PutAsync",
		GenOverloads(item, returnOldItem, cancellationToken));
	var put = new Method("DynamoDBMap", "Put",
		GenOverloads(item, returnOldItem));
	var updateAsync = new Method("Task<DynamoDBMap>", "UpdateAsync",
		GenOverloads(updateExp, values, updateReturnValue, cancellationToken));
	var update = new Method("DynamoDBMap", "Update",
		GenOverloads(updateExp, values, updateReturnValue));
	var tryUpdateAsync = new Method("Task<bool>", "TryUpdateAsync",
		GenOverloads(updateExp, values, cancellationToken));
	var tryUpdate = new Method("bool", "TryUpdate",
		GenOverloads(updateExp, values));
	var deleteAsync = new Method("Task<DynamoDBMap>", "DeleteAsync",
		GenOverloads(returnOldItem, cancellationToken));
	var delete = new Method("DynamoDBMap", "Delete",
		GenOverloads(returnOldItem));
	var query = new Method("IReverseSyntax", "Query", "new QueryContext",
		GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKey, filter, values)
		.Concat(GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKey, converterSkipped, filter, values))
		.Concat(GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKeyObject, filter, values))
		.Concat(GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var scanAllAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "AllAsync",
		GenOverloads(readAhead));
	var scanSegmentAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "SegmentAsync",
		GenOverloads(segment, totalSegments, readAhead));
	var scan = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		GenOverloads(true, tableArg, indexNoneArg, projectionArg, filter, values)
		.Where(noValuesWithoutFilter));
	var indexQuery = new Method("IReverseSyntax", "Query", "new QueryContext",
		GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKey, filter, values)
		.Concat(GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKey, converterSkipped, filter, values))
		.Concat(GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKeyObject, filter, values))
		.Concat(GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var indexScan = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		GenOverloads(true, indexDotTableArg, indexArg, projectionArg, filter, values)
		.Where(noValuesWithoutFilter));

	// Query Range
	var allKeysAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "AllKeysAsync", GenOverloads(readAhead));
	var rangeKeyBeginsWithAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyBeginsWithAsync",
		GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyBeginsWith = new Method("IEnumerable<DynamoDBMap>", "RangeKeyBeginsWith",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyEqualsAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyEqualsAsync",
		GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyEquals = new Method("IEnumerable<DynamoDBMap>", "RangeKeyEquals",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyLessThanAsync",
		GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyLessThan = new Method("IEnumerable<DynamoDBMap>", "RangeKeyLessThan",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanOrEqualToAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyLessThanOrEqualToAsync",
		GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyLessThanOrEqualTo = new Method("IEnumerable<DynamoDBMap>", "RangeKeyLessThanOrEqualTo",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyGreaterThanAsync",
		GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyGreaterThan = new Method("IEnumerable<DynamoDBMap>", "RangeKeyGreaterThan",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanOrEqualToAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyGreaterThanOrEqualToAsync",
		GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyGreaterThanOrEqualTo = new Method("IEnumerable<DynamoDBMap>", "RangeKeyGreaterThanOrEqualTo",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyBetweenAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyBetweenAsync",
		GenOverloads(false, rangeKeyBetweenOverloads, readAhead));
	var rangeKeyBetween = new Method("IEnumerable<DynamoDBMap>", "RangeKeyBetween",
		GenOverloads(false, rangeKeyBetweenOverloads));

	// Query Range Paged
	var allKeysAsyncPaged = new Method("Task<ItemPage>", "AllKeysAsync", GenOverloads(cancellationToken));
	var rangeKeyBeginsWithAsyncPaged = new Method("Task<ItemPage>", "RangeKeyBeginsWithAsync",
		GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyBeginsWithPaged = new Method("ItemPage", "RangeKeyBeginsWith",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyEqualsAsyncPaged = new Method("Task<ItemPage>", "RangeKeyEqualsAsync",
		GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyEqualsPaged = new Method("ItemPage", "RangeKeyEquals",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanAsyncPaged = new Method("Task<ItemPage>", "RangeKeyLessThanAsync",
		GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyLessThanPaged = new Method("ItemPage", "RangeKeyLessThan",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanOrEqualToAsyncPaged = new Method("Task<ItemPage>", "RangeKeyLessThanOrEqualToAsync",
		GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyLessThanOrEqualToPaged = new Method("ItemPage", "RangeKeyLessThanOrEqualTo",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanAsyncPaged = new Method("Task<ItemPage>", "RangeKeyGreaterThanAsync",
		GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyGreaterThanPaged = new Method("ItemPage", "RangeKeyGreaterThan",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanOrEqualToAsyncPaged = new Method("Task<ItemPage>", "RangeKeyGreaterThanOrEqualToAsync",
		GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyGreaterThanOrEqualToPaged = new Method("ItemPage", "RangeKeyGreaterThanOrEqualTo",
		GenOverloads(false, rangeKeyOverloads));
	var rangeKeyBetweenAsyncPaged = new Method("Task<ItemPage>", "RangeKeyBetweenAsync",
		GenOverloads(false, rangeKeyBetweenOverloads, cancellationToken));
	var rangeKeyBetweenPaged = new Method("ItemPage", "RangeKeyBetween",
		GenOverloads(false, rangeKeyBetweenOverloads));

	// Scan Options Paged
	var scanAllAsyncPaged = new Method("Task<ItemPage>", "AllAsync", GenOverloads(cancellationToken));
	var scanSegmentAsyncPaged = new Method("Task<ItemPage>", "SegmentAsync", GenOverloads(segment, totalSegments, cancellationToken));
#>
using Adamantworks.Amazon.DynamoDB.Contexts;
using Adamantworks.Amazon.DynamoDB.Converters;
using Adamantworks.Amazon.DynamoDB.DynamoDBValues;
using Adamantworks.Amazon.DynamoDB.Schema;
using Adamantworks.Amazon.DynamoDB.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Adamantworks.Amazon.DynamoDB
{
	public partial interface IDynamoDBRegion
	{
<#		GenInterface(listTablesAsync); #>

<#		GenInterface(listTablesWithPrefixAsync); #>

<#		GenInterface(createTableAsync); #>
<#		GenInterface(createTable); #>
	}

	internal partial class Region
	{
<#		GenMethods(listTablesAsync); #>

<#		GenMethods(listTablesWithPrefixAsync); #>

<#		GenMethods(createTableAsync); #>

<#		GenMethods(createTable); #>
	}

	public partial interface ITable
	{
<#		GenInterface(reloadAsync); #>

<#		GenInterface(waitUntilNotAsync); #>

<#		GenInterface(updateTableAsync); #>
<#		GenInterface(updateTable); #>

<#		GenInterface(forKey); #>

<#		GenInterface(batchDeleteAsync); #>
<#		GenInterface(batchDelete); #>
	}

	internal partial class Table
	{
<#		GenMethods(reloadAsync); #>

<#		GenMethods(waitUntilNotAsync); #>

<#		GenMethods(updateTableAsync); #>

<#		GenMethods(updateTable); #>

<#		GenMethods(getAsyncForwards); #>

<#		GenMethods(getForwards); #>

<#		GenMethods(batchGetAsyncForwards); #>

<#		GenMethods(batchGetForwards); #>

<#		GenMethods(batchGetJoinAsyncForwards); #>

<#		GenMethods(batchGetJoinForwards); #>

<#		GenMethods(forKey); #>

<#		GenMethods(putAsyncForwards); #>

<#		GenMethods(putForwards); #>

<#		GenMethods(queryForwards); #>

<#		GenMethods(scanForwards); #>

<#		GenMethods(batchDeleteAsync); #>

<#		GenMethods(batchDelete); #>
	}

	internal partial class Index
	{
<#		GenMethods(indexQueryForwards); #>

<#		GenMethods(indexScanForwards); #>
	}
}

namespace Adamantworks.Amazon.DynamoDB.Syntax
{
	public partial interface IGetSyntax
	{
<#		GenInterface(getAsync); #>
<#		GenInterface(get); #>

<#		GenInterface(batchGetAsync); #>
<#		GenInterface(batchGet); #>

<#		GenInterface(batchGetJoinAsync); #>
<#		GenInterface(batchGetJoin); #>
	}

	public partial interface IModifySyntax
	{
<#		GenInterface(updateAsync); #>
<#		GenInterface(update); #>

<#		GenInterface(deleteAsync); #>
<#		GenInterface(delete); #>
	}

	public partial interface IPagedQueryRangeSyntax
	{
<#		GenInterface(allKeysAsyncPaged); #>

<#		GenInterface(rangeKeyBeginsWithAsyncPaged); #>
<#		GenInterface(rangeKeyBeginsWithPaged); #>

<#		GenInterface(rangeKeyEqualsAsyncPaged); #>
<#		GenInterface(rangeKeyEqualsPaged); #>

<#		GenInterface(rangeKeyLessThanAsyncPaged); #>
<#		GenInterface(rangeKeyLessThanPaged); #>

<#		GenInterface(rangeKeyLessThanOrEqualToAsyncPaged); #>
<#		GenInterface(rangeKeyLessThanOrEqualToPaged); #>

<#		GenInterface(rangeKeyGreaterThanAsyncPaged); #>
<#		GenInterface(rangeKeyGreaterThanPaged); #>

<#		GenInterface(rangeKeyGreaterThanOrEqualToAsyncPaged); #>
<#		GenInterface(rangeKeyGreaterThanOrEqualToPaged); #>

<#		GenInterface(rangeKeyBetweenAsyncPaged); #>
<#		GenInterface(rangeKeyBetweenPaged); #>
	}

	public partial interface IPagedScanOptionsSyntax
	{
<#		GenInterface(scanAllAsyncPaged); #>

<#		GenInterface(scanSegmentAsyncPaged); #>
	}

	public partial interface IPutSyntax
	{
<#		GenInterface(putAsync); #>
<#		GenInterface(put); #>
	}

	public partial interface IQueryRangeSyntax
	{
<#		GenInterface(allKeysAsync); #>

<#		GenInterface(rangeKeyBeginsWithAsync); #>
<#		GenInterface(rangeKeyBeginsWith); #>

<#		GenInterface(rangeKeyEqualsAsync); #>
<#		GenInterface(rangeKeyEquals); #>

<#		GenInterface(rangeKeyLessThanAsync); #>
<#		GenInterface(rangeKeyLessThan); #>

<#		GenInterface(rangeKeyLessThanOrEqualToAsync); #>
<#		GenInterface(rangeKeyLessThanOrEqualTo); #>

<#		GenInterface(rangeKeyGreaterThanAsync); #>
<#		GenInterface(rangeKeyGreaterThan); #>

<#		GenInterface(rangeKeyGreaterThanOrEqualToAsync); #>
<#		GenInterface(rangeKeyGreaterThanOrEqualTo); #>

<#		GenInterface(rangeKeyBetweenAsync); #>
<#		GenInterface(rangeKeyBetween); #>
	}

	public partial interface IQuerySyntax
	{
<#		GenInterface(query); #>
	}

	public partial interface IScanOptionsSyntax
	{
<#		GenInterface(scanAllAsync); #>

<#		GenInterface(scanSegmentAsync); #>
	}

	public partial interface IScanSyntax
	{
<#		GenInterface(scan); #>
	}

	public partial interface ITryModifySyntax
	{
<#		GenInterface(tryUpdateAsync); #>
<#		GenInterface(tryUpdate); #>
	}
}

namespace Adamantworks.Amazon.DynamoDB.Contexts
{
	internal partial class GetContext
	{
<#		GenMethods(getAsync); #>

<#		GenMethods(get); #>

<#		GenMethods(batchGetAsync); #>

<#		GenMethods(batchGet); #>

<#		GenMethods(batchGetJoinAsync); #>

<#		GenMethods(batchGetJoin); #>

<#		GenMethods(query); #>

<#		GenMethods(scan); #>
	}

	internal partial class IndexContext
	{
<#		GenMethods(indexQuery); #>

<#		GenMethods(indexScan); #>
	}

	internal partial class ModifyContext
	{
<#		GenMethods(updateAsync); #>

<#		GenMethods(update); #>

<#		GenMethods(tryUpdateAsync); #>

<#		GenMethods(tryUpdate); #>

<#		GenMethods(deleteAsync); #>

<#		GenMethods(delete); #>
	}

	internal partial class PutContext
	{
<#		GenMethods(putAsync); #>

<#		GenMethods(put); #>
	}

	internal partial class QueryContext
	{
<#		GenMethods(allKeysAsync); #>

<#		GenMethods(rangeKeyBeginsWithAsync); #>

<#		GenMethods(rangeKeyBeginsWith); #>

<#		GenMethods(rangeKeyEqualsAsync); #>

<#		GenMethods(rangeKeyEquals); #>

<#		GenMethods(rangeKeyLessThanAsync); #>

<#		GenMethods(rangeKeyLessThan); #>

<#		GenMethods(rangeKeyLessThanOrEqualToAsync); #>

<#		GenMethods(rangeKeyLessThanOrEqualTo); #>

<#		GenMethods(rangeKeyGreaterThanAsync); #>

<#		GenMethods(rangeKeyGreaterThan); #>

<#		GenMethods(rangeKeyGreaterThanOrEqualToAsync); #>

<#		GenMethods(rangeKeyGreaterThanOrEqualTo); #>

<#		GenMethods(rangeKeyBetweenAsync); #>

<#		GenMethods(rangeKeyBetween); #>

<#		GenExplicitImplementations(allKeysAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyBeginsWithAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyBeginsWithPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyEqualsAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyEqualsPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyLessThanAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyLessThanPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyLessThanOrEqualToAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyLessThanOrEqualToPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyGreaterThanAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyGreaterThanPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyGreaterThanOrEqualToAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyGreaterThanOrEqualToPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyBetweenAsyncPaged, "IPagedQueryRangeSyntax"); #>

<#		GenExplicitImplementations(rangeKeyBetweenPaged, "IPagedQueryRangeSyntax"); #>
	}

	internal partial class ScanContext
	{
<#		GenMethods(scanAllAsync); #>

<#		GenExplicitImplementations(scanAllAsyncPaged, "IPagedScanOptionsSyntax"); #>

<#		GenMethods(scanSegmentAsync); #>

<#		GenExplicitImplementations(scanSegmentAsyncPaged, "IPagedScanOptionsSyntax"); #>
	}
}
<#+
	public Parameter Param(string type, string name)
	{
		return new Parameter(type, name, null, name);
	}
	public Parameter Param(string type, string name, string defaultValue)
	{
		return new Parameter(type, name, defaultValue, name);
	}
	public Parameter ParamTransform(string type, string name, string value)
	{
		return new Parameter(type, name, null, value);
	}
	public Parameter ParamTransform(string type, string name, string value, string defaultValue)
	{
		return new Parameter(type, name, defaultValue, value);
	}
	public Parameter Argument(string value)
	{
		return new Parameter(null, null, null, value);
	}

	public IEnumerable<IReadOnlyList<Parameter>> GenOverloads(params Parameter[] parameters)
	{
		return GenOverloads(false, Enumerable.Empty<IReadOnlyList<Parameter>>(), parameters);
	}

	public IEnumerable<IReadOnlyList<Parameter>> GenOverloads(bool includeAll, params Parameter[] parameters)
	{
		return GenOverloads(includeAll, Enumerable.Empty<IReadOnlyList<Parameter>>(), parameters);
	}

	public IEnumerable<IReadOnlyList<Parameter>> GenOverloads(bool includeAll, Parameter beforeParam, IEnumerable<IReadOnlyList<Parameter>> baseOverloads)
	{
		var overloads = baseOverloads.Select(overload =>
		{
			var newOverload = overload.ToList();
			newOverload.Insert(0, beforeParam);
			return newOverload;
		}).ToList();
		if(!includeAll)
			overloads.RemoveAt(overloads.Count-1); // The last one has no defaults
		return overloads;
	}

	public IEnumerable<IReadOnlyList<Parameter>> GenOverloads(bool includeAll, IEnumerable<IReadOnlyList<Parameter>> baseOverloads, params Parameter[] parameters)
	{
		var paramsList = parameters.ToList();
		var overloads = baseOverloads.Select(overload => overload.ToList()).ToList();
		if(overloads.Count == 0) // Empty base to start from
			overloads.Add(new List<Parameter>());
		foreach(var param in parameters)
		{
			// params that exist only to pass values, or aren't optional, we tack onto all overloads
			if(param.Name == null || param.DefaultValue == null)
			{
				foreach(var overload in overloads)
					overload.Add(param);
			}
			else
			{
				var ovarloadsWithParam = overloads.Select(o =>
					{
						var overload = new List<Parameter>(o);
						overload.Add(param);
						return overload;
					}).ToList(); // So we gen them before changing overloads

				// overloads without the param need the default value
				foreach(var overload in overloads)
					overload.Add(param.Default);

				overloads.AddRange(ovarloadsWithParam);
			}
		}
		if(!includeAll)
			overloads.RemoveAt(overloads.Count-1); // The last one has no defaults
		return overloads;
	}

	public void GenInterface(Method method)
	{
		foreach(var overload in method.ParameterOverloads)
		{
#>		<#+ GenDeclaration(method, overload); #>;
<#+
		}
	}

	public void GenMethods(Method method)
	{
#>		#region <#= method.Name #>
<#+		foreach(var overload in method.ParameterOverloads)
		{
#>		public <#+ GenDeclaration(method, overload); #>

		{
<#+ GenMethodCall(method, overload);#>
		}
<#+
		}
#>		#endregion
<#+
	}

	public void GenExplicitImplementations(Method method, string @interface)
	{
#>		#region <#= @interface#>.<#= method.Name #>
<#+		foreach(var overload in method.ParameterOverloads)
		{
#>		<#+ GenDeclaration(method, overload, @interface); #>

		{
<#+ GenMethodCall(method, overload, @interface);#>
		}
<#+
		}
#>		#endregion
<#+
	}

	public void GenDeclaration(Method method, IReadOnlyList<Parameter> overload, string @interface = null)
	{
		#><#= method.ReturnType #> <#= @interface != null ? @interface + "." : "" #><#= method.Name #>(<#+
		var firstParam = true;
		foreach(var param in overload)
			if(param.Name != null)
			{
				if(firstParam)
					firstParam = false;
				else
					#>, <#+
				#><#= param.Type #> <#= param.Name #><#+
			}
		#>)<#+
	}

	public void GenMethodCall(Method method, IReadOnlyList<Parameter> overload, string @interface = null)
	{
#>			<#+if(method.ReturnType != "void")
				#>return <#+
			#><#= @interface != null ? "(("+@interface + ")this)." : "" #><#= method.Call #>(<#+
			var firstParam = true;
			foreach(var param in overload)
				if(param.Value != null)
				{
					if(firstParam)
						firstParam = false;
					else
						#>, <#+
					#><#= param.Value #><#+
				}
			#>);
<#+
	}

	public class Method
	{
		public readonly string ReturnType;
		public readonly string Name;
		public readonly string Call;
		public readonly IReadOnlyList<IReadOnlyList<Parameter>> ParameterOverloads;

		public Method(string returnType, string name, IEnumerable<IReadOnlyList<Parameter>> parameterOverloads)
			: this(returnType, name, name, parameterOverloads)
		{
		}

		public Method(string returnType, string name, string call, IEnumerable<IReadOnlyList<Parameter>> parameterOverloads)
		{
			ReturnType = returnType;
			Name = name;
			Call = call;
			ParameterOverloads = parameterOverloads.ToList();
		}
	}

	public class Parameter
	{
		public readonly string Type;
		public readonly string Name;
		public readonly string DefaultValue;
		public readonly string Value;
		public readonly Parameter Default;

		public Parameter(string type, string name, string defaultValue, string value)
		{
			Type = type;
			Name = name;
			DefaultValue = defaultValue;
			Value = value;
			if(name != null)
				Default = new Parameter(null, null, null, defaultValue ?? value);
		}
	}
#>
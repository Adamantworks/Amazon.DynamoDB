// Copyright 2015 Adamantworks.  All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="$(SolutionDir)DynamoDB.CodeGen\bin\Debug\Adamantworks.Amazon.DynamoDB.CodeGen.dll" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Adamantworks.Amazon.DynamoDB.CodeGen" #>
<#
	var itemKey = Parameter.Of("ItemKey","key");
	var projection = Parameter.Of("ProjectionExpression", "projection", "null");
	var consistent = Parameter.Of("bool","consistent","false");
	var cancellationToken = Parameter.Of("CancellationToken", "cancellationToken","CancellationToken.None");
	var hashKeyOnly = Parameter.Transform("DynamoDBKeyValue", "hashKey", "ItemKey.Create(hashKey)");
	var hashKeyObjectOnly = Parameter.Transform("object", "hashKey", "ItemKey.Create(hashKey)");
	var hashKeySkipped = Parameter.Transform("DynamoDBKeyValue", "hashKey", null);
	var hashKeyObjectSkipped = Parameter.Transform("object", "hashKey", null);
	var rangeKey = Parameter.Transform("DynamoDBKeyValue", "rangeKey", "ItemKey.Create(hashKey, rangeKey)");
	var rangeKeyObject = Parameter.Transform("object", "rangeKey", "ItemKey.Create(hashKey, rangeKey)");
	var rangeKeySkipped = Parameter.Transform("DynamoDBKeyValue", "rangeKey", null);
	var rangeKeyObjectSkipped = Parameter.Transform("object", "rangeKey", null);
	var converterHash = Parameter.Transform("IValueConverter", "converter", "ItemKey.Create(hashKey, converter)");
	var converterHashAndRange = Parameter.Transform("IValueConverter", "converter", "ItemKey.Create(hashKey, rangeKey, converter)");
	var status = Parameter.Of("CollectionStatus","status");
	var timeout = Parameter.Of("TimeSpan", "timeout");
	var provisionedThroughput = Parameter.Transform("ProvisionedThroughput", "provisionedThroughput","(ProvisionedThroughput?)provisionedThroughput", "null");
	var indexProvisionedThroughputs = Parameter.Of("IReadOnlyDictionary<string, ProvisionedThroughput>", "indexProvisionedThroughputs", "null");
	var keysAsync = Parameter.Of("IAsyncEnumerable<ItemKey>", "keys");
	var keysSyncToAsync = Parameter.Transform("IEnumerable<ItemKey>", "keys", "keys.ToAsyncEnumerable()");
	var keys = Parameter.Of("IEnumerable<ItemKey>", "keys");
	var tableNamePrefix = Parameter.Of("string", "tableNamePrefix");
	var readAhead = Parameter.Of("ReadAhead", "readAhead", "ReadAhead.Some");
	var outerItemsAsync = Parameter.Of("IAsyncEnumerable<T>", "outerItems");
	var outerItemsSyncToAsync = Parameter.Transform("IEnumerable<T>", "outerItems", "outerItems.ToAsyncEnumerable()");
	var outerItemsSync = Parameter.Of("IEnumerable<T>", "outerItems");
	var keySelector = Parameter.Of("Func<T, ItemKey>","keySelector");
	var resultSelector = Parameter.Of("Func<T, DynamoDBMap, TResult>", "resultSelector");
	var item = Parameter.Of("DynamoDBMap", "item");
	var values = Parameter.Of("Values", "values", "null");
	var returnOldItem = Parameter.Of("bool", "returnOldItem", "false");
	var updateExp  = Parameter.Of("UpdateExpression", "update");
	var updateReturnValue = Parameter.Of("UpdateReturnValue", "returnValue", "UpdateReturnValue.None");
	var indexTableArg = Parameter.Argument("Table");
	var indexNoneArg = Parameter.Argument("null");
	var tableArg = Parameter.Argument("table");
	var indexDotTableArg = Parameter.Argument("index.Table");
	var indexArg = Parameter.Argument("index");
	var projectionNoneArg = Parameter.Argument("null");
	var projectionArg = Parameter.Argument("projection");
	var consistentNoneArg = Parameter.Argument("false");
	var consistentArg = Parameter.Argument("consistentRead ?? false");
	var hashKey = Parameter.Of("DynamoDBKeyValue", "hashKey");
	var hashKeyObject = Parameter.Transform("object", "hashKey", "DynamoDBKeyValue.Convert(hashKey)");
	var hashKeyObjectConverter = Parameter.Transform("object", "hashKey", "DynamoDBKeyValue.Convert(hashKey, converter)");
	var converterSkipped = Parameter.Transform("IValueConverter", "converter", null);
	var filter = Parameter.Of("PredicateExpression", "filter", "null");
	var tableName = Parameter.Of("string", "tableName");
	var schema = Parameter.Of("TableSchema", "schema");
	var thisArg = Parameter.Argument("this");
	var rangeKeyOnly = Parameter.Of("DynamoDBKeyValue", "rangeKey");
	var rangeKeyOnlyObject = Parameter.Transform("object", "rangeKey", "DynamoDBKeyValue.Convert(rangeKey)");
	var rangeKeyOnlyObjectConverter = Parameter.Transform("object", "rangeKey", "DynamoDBKeyValue.Convert(rangeKey, converter)");
	var batchWrite = Parameter.Of("IBatchWrite", "batch");
	var batchWriteAsync = Parameter.Of("IBatchWriteAsync", "batch");
	var segment = Parameter.Of("int", "segment");
	var totalSegments = Parameter.Of("int", "totalSegments");

	Func<IReadOnlyList<Parameter>, bool> noIndexThroughputWithoutTableThroughput = overload => !(overload.Contains(indexProvisionedThroughputs) && ! overload.Contains(provisionedThroughput));
	Func<IReadOnlyList<Parameter>, bool> noValuesWithoutFilter = overload => !(overload.Contains(values) && !overload.Contains(filter));

	var keyOverloads = Parameters.GenOverloads(true, hashKeyOnly)
		.Concat(Parameters.GenOverloads(true, hashKeySkipped, converterHash))
		.Concat(Parameters.GenOverloads(true, hashKeyObjectOnly))
		.Concat(Parameters.GenOverloads(true, hashKeyObjectSkipped, converterHash))
		.Concat(Parameters.GenOverloads(true, hashKeySkipped, rangeKey))
		.Concat(Parameters.GenOverloads(true, hashKeySkipped, rangeKeySkipped, converterHashAndRange))
		.Concat(Parameters.GenOverloads(true, hashKeyObjectSkipped, rangeKey))
		.Concat(Parameters.GenOverloads(true, hashKeyObjectSkipped, rangeKeySkipped, converterHashAndRange))
		.Concat(Parameters.GenOverloads(true, hashKeySkipped, rangeKeyObject))
		.Concat(Parameters.GenOverloads(true, hashKeySkipped, rangeKeyObjectSkipped, converterHashAndRange))
		.Concat(Parameters.GenOverloads(true, hashKeyObjectSkipped, rangeKeyObject))
		.Concat(Parameters.GenOverloads(true, hashKeyObjectSkipped, rangeKeyObjectSkipped, converterHashAndRange))
		.Concat(Parameters.GenOverloads(true, itemKey))
		.ToList();

	var rangeKeyOverloads =
		Parameters.GenOverloads(true, rangeKeyOnlyObjectConverter, converterSkipped)
		.Concat(Parameters.GenOverloads(true, rangeKeyOnlyObject))
		.Concat(Parameters.GenOverloads(true, rangeKeyOnly, converterSkipped))
		.Concat(Parameters.GenOverloads(true, rangeKeyOnly))
		.ToList();

	var startInclusive = Parameter.Of("DynamoDBKeyValue", "startInclusive");
	var startInclusiveObject = Parameter.Transform("object", "startInclusive", "DynamoDBKeyValue.Convert(startInclusive)");
	var startInclusiveObjectConverter = Parameter.Transform("object", "startInclusive", "DynamoDBKeyValue.Convert(startInclusive, converter)");
	var endExclusive = Parameter.Of("DynamoDBKeyValue", "endExclusive");
	var endExclusiveObject = Parameter.Transform("object", "endExclusive", "DynamoDBKeyValue.Convert(endExclusive)");
	var endExclusiveObjectConverter = Parameter.Transform("object", "endExclusive", "DynamoDBKeyValue.Convert(endExclusive, converter)");
	var rangeKeyBetweenOverloads =
		Parameters.GenOverloads(true, startInclusiveObjectConverter, endExclusiveObjectConverter, converterSkipped)
		.Concat(Parameters.GenOverloads(true, startInclusiveObject, endExclusiveObject))
		.Concat(Parameters.GenOverloads(true, startInclusiveObjectConverter, endExclusive, converterSkipped))
		.Concat(Parameters.GenOverloads(true, startInclusiveObject, endExclusive))
		.Concat(Parameters.GenOverloads(true, startInclusive, endExclusiveObjectConverter, converterSkipped))
		.Concat(Parameters.GenOverloads(true, startInclusive, endExclusiveObject))
		.Concat(Parameters.GenOverloads(true, startInclusive, endExclusive, converterSkipped))
		.Concat(Parameters.GenOverloads(true, startInclusive, endExclusive))
		.ToList();

	// Region
	var listTablesAsync = new Method("IAsyncEnumerable<string>", "ListTablesAsync", Parameters.GenOverloads(readAhead));
	var listTablesWithPrefixAsync = new Method("IAsyncEnumerable<string>", "ListTablesWithPrefixAsync", Parameters.GenOverloads(tableNamePrefix, readAhead));
	var createTableAsync = new Method("Task<ITable>", "CreateTableAsync",
		Parameters.GenOverloads(true, tableName, schema, provisionedThroughput, indexProvisionedThroughputs, cancellationToken)
		.Where(noIndexThroughputWithoutTableThroughput));
	var createTable = new Method("ITable", "CreateTable",
		Parameters.GenOverloads(true, tableName, schema, provisionedThroughput, indexProvisionedThroughputs)
		.Where(noIndexThroughputWithoutTableThroughput));

	// Table
	var reloadAsync = new Method("Task", "ReloadAsync", Parameters.GenOverloads(cancellationToken));
	var waitUntilNotAsync = new Method("Task", "WaitUntilNotAsync",
		Parameters.GenOverloads(status, cancellationToken)
		.Concat(Parameters.GenOverloads(status, timeout, cancellationToken)));
	var updateTableAsync = new Method("Task", "UpdateTableAsync",
		Parameters.GenOverloads(true, provisionedThroughput, indexProvisionedThroughputs, cancellationToken)
		// must pass either provisionedThroughput or indexProvisionedThroughputs
		.Where(overload => overload.Contains(provisionedThroughput) || overload.Contains(indexProvisionedThroughputs)));
	var updateTable = new Method("void", "UpdateTable",
		Parameters.GenOverloads(true, provisionedThroughput, indexProvisionedThroughputs)
		// must pass either provisionedThroughput or indexProvisionedThroughputs
		.Where(overload => overload.Contains(provisionedThroughput) || overload.Contains(indexProvisionedThroughputs)));
	var getAsyncForwards = new Method("Task<DynamoDBMap>", "GetAsync", "eventuallyConsistentContext.GetAsync",
		Parameters.GenOverloads(true, keyOverloads, cancellationToken));
	var getForwards = new Method("DynamoDBMap", "Get", "eventuallyConsistentContext.Get", keyOverloads);
	var batchGetAsyncForwards = new Method("IAsyncEnumerable<DynamoDBMap>", "BatchGetAsync", "eventuallyConsistentContext.BatchGetAsync",
		Parameters.GenOverloads(true, keysSyncToAsync, readAhead)
		.Concat(Parameters.GenOverloads(true, keysAsync, readAhead)));
	var batchGetForwards = new Method("IEnumerable<DynamoDBMap>", "BatchGet", "eventuallyConsistentContext.BatchGet",
		Parameters.GenOverloads(true, keys));
	var batchGetJoinAsyncForwards = new Method("IAsyncEnumerable<TResult>", "BatchGetJoinAsync<T, TResult>", "eventuallyConsistentContext.BatchGetJoinAsync",
		Parameters.GenOverloads(true, outerItemsSyncToAsync, keySelector, resultSelector, readAhead)
		.Concat(Parameters.GenOverloads(true, outerItemsAsync, keySelector, resultSelector, readAhead)));
	var batchGetJoinForwards = new Method("IEnumerable<TResult>", "BatchGetJoin<T, TResult>", "eventuallyConsistentContext.BatchGetJoin",
		Parameters.GenOverloads(true, outerItemsSync, keySelector, resultSelector));
	var forKey = new Method("IIfSyntax", "ForKey", "new ModifyContext", Parameters.GenOverloads(true, thisArg,  keyOverloads));
	var putAsyncForwards = new Method("Task<DynamoDBMap>", "PutAsync", "putContext.PutAsync",
		Parameters.GenOverloads(true, item, returnOldItem, cancellationToken));
	var putForwards = new Method("DynamoDBMap", "Put", "putContext.Put",
		Parameters.GenOverloads(true, item, returnOldItem));
	var queryForwards = new Method("IReverseSyntax", "Query", "new QueryContext",
		Parameters.GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, consistentNoneArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var queryCountForwards = new Method("IQueryCountRangeSyntax", "QueryCount", "new QueryCountContext",
		Parameters.GenOverloads(true, thisArg, indexNoneArg, consistentNoneArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, thisArg, indexNoneArg, consistentNoneArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, thisArg, indexNoneArg, consistentNoneArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, thisArg, indexNoneArg, consistentNoneArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var scanForwards = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		Parameters.GenOverloads(true, thisArg, indexNoneArg, projectionNoneArg, filter, values)
		.Where(noValuesWithoutFilter));
	var indexQueryForwards = new Method("IReverseSyntax", "Query", "new QueryContext",
		Parameters.GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, consistentNoneArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var indexQueryCountForwards = new Method("IQueryCountRangeSyntax", "QueryCount", "new QueryCountContext",
		Parameters.GenOverloads(true, indexTableArg, thisArg, consistentNoneArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, indexTableArg, thisArg, consistentNoneArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, indexTableArg, thisArg, consistentNoneArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, indexTableArg, thisArg, consistentNoneArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var indexScanForwards = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		Parameters.GenOverloads(true, indexTableArg, thisArg, projectionNoneArg, filter, values)
		.Where(noValuesWithoutFilter));
	var batchDelete = new Method("void", "Delete",
			Parameters.GenOverloads(false, batchWrite, keyOverloads));
	var batchDeleteAsync = new Method("void", "Delete",
			Parameters.GenOverloads(false, batchWriteAsync, keyOverloads));

	// Syntax
	var getAsync = new Method("Task<DynamoDBMap>", "GetAsync",
		Parameters.GenOverloads(false, keyOverloads, cancellationToken));
	var get = new Method("DynamoDBMap", "Get",
		Parameters.GenOverloads(false, keyOverloads));
	var batchGetAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "BatchGetAsync",
		Parameters.GenOverloads(true, keysSyncToAsync, readAhead)
		.Concat(Parameters.GenOverloads(keysAsync, readAhead)));
	var batchGet = new Method("IEnumerable<DynamoDBMap>", "BatchGet",
		Parameters.GenOverloads(keys));
	var batchGetJoinAsync = new Method("IAsyncEnumerable<TResult>", "BatchGetJoinAsync<T, TResult>",
		Parameters.GenOverloads(true, outerItemsSyncToAsync, keySelector, resultSelector, readAhead)
		.Concat(Parameters.GenOverloads(outerItemsAsync, keySelector, resultSelector, readAhead)));
	var batchGetJoin = new Method("IEnumerable<TResult>", "BatchGetJoin<T, TResult>",
		Parameters.GenOverloads(outerItemsSync, keySelector, resultSelector));
	var putAsync = new Method("Task<DynamoDBMap>", "PutAsync",
		Parameters.GenOverloads(item, returnOldItem, cancellationToken));
	var put = new Method("DynamoDBMap", "Put",
		Parameters.GenOverloads(item, returnOldItem));
	var updateAsync = new Method("Task<DynamoDBMap>", "UpdateAsync",
		Parameters.GenOverloads(updateExp, values, updateReturnValue, cancellationToken));
	var update = new Method("DynamoDBMap", "Update",
		Parameters.GenOverloads(updateExp, values, updateReturnValue));
	var tryUpdateAsync = new Method("Task<bool>", "TryUpdateAsync",
		Parameters.GenOverloads(updateExp, values, cancellationToken));
	var tryUpdate = new Method("bool", "TryUpdate",
		Parameters.GenOverloads(updateExp, values));
	var deleteAsync = new Method("Task<DynamoDBMap>", "DeleteAsync",
		Parameters.GenOverloads(returnOldItem, cancellationToken));
	var delete = new Method("DynamoDBMap", "Delete",
		Parameters.GenOverloads(returnOldItem));
	var query = new Method("IReverseSyntax", "Query", "new QueryContext",
		Parameters.GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, tableArg, indexNoneArg, projectionArg, consistentArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var queryCount = new Method("IQueryCountRangeSyntax", "QueryCount", "new QueryCountContext",
		Parameters.GenOverloads(true, tableArg, indexNoneArg, consistentArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, tableArg, indexNoneArg, consistentArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, tableArg, indexNoneArg, consistentArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, tableArg, indexNoneArg, consistentArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var scanAllAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "AllAsync",
		Parameters.GenOverloads(readAhead));
	var scanSegmentAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "SegmentAsync",
		Parameters.GenOverloads(segment, totalSegments, readAhead));
	var scan = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		Parameters.GenOverloads(true, tableArg, indexNoneArg, projectionArg, filter, values)
		.Where(noValuesWithoutFilter));
	var indexQuery = new Method("IReverseSyntax", "Query", "new QueryContext",
		Parameters.GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, indexDotTableArg, indexArg, projectionArg, consistentArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var indexQueryCount = new Method("IQueryCountRangeSyntax", "QueryCount", "new QueryCountContext",
		Parameters.GenOverloads(true, indexDotTableArg, indexArg, consistentArg, hashKey, filter, values)
		.Concat(Parameters.GenOverloads(true, indexDotTableArg, indexArg, consistentArg, hashKey, converterSkipped, filter, values))
		.Concat(Parameters.GenOverloads(true, indexDotTableArg, indexArg, consistentArg, hashKeyObject, filter, values))
		.Concat(Parameters.GenOverloads(true, indexDotTableArg, indexArg, consistentArg, hashKeyObjectConverter, converterSkipped, filter, values))
		.Where(noValuesWithoutFilter));
	var indexScan = new Method("IScanLimitToOrPagedSyntax", "Scan", "new ScanContext",
		Parameters.GenOverloads(true, indexDotTableArg, indexArg, projectionArg, filter, values)
		.Where(noValuesWithoutFilter));

	// Query Range
	var allKeysAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "AllKeysAsync", Parameters.GenOverloads(readAhead));
	var rangeKeyBeginsWithAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyBeginsWithAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyBeginsWith = new Method("IEnumerable<DynamoDBMap>", "RangeKeyBeginsWith",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyEqualsAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyEqualsAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyEquals = new Method("IEnumerable<DynamoDBMap>", "RangeKeyEquals",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyLessThanAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyLessThan = new Method("IEnumerable<DynamoDBMap>", "RangeKeyLessThan",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanOrEqualToAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyLessThanOrEqualToAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyLessThanOrEqualTo = new Method("IEnumerable<DynamoDBMap>", "RangeKeyLessThanOrEqualTo",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyGreaterThanAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyGreaterThan = new Method("IEnumerable<DynamoDBMap>", "RangeKeyGreaterThan",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanOrEqualToAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyGreaterThanOrEqualToAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, readAhead));
	var rangeKeyGreaterThanOrEqualTo = new Method("IEnumerable<DynamoDBMap>", "RangeKeyGreaterThanOrEqualTo",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyBetweenAsync = new Method("IAsyncEnumerable<DynamoDBMap>", "RangeKeyBetweenAsync",
		Parameters.GenOverloads(false, rangeKeyBetweenOverloads, readAhead));
	var rangeKeyBetween = new Method("IEnumerable<DynamoDBMap>", "RangeKeyBetween",
		Parameters.GenOverloads(false, rangeKeyBetweenOverloads));

	// Query Range Paged
	var allKeysAsyncPaged = new Method("Task<ItemPage>", "AllKeysAsync", Parameters.GenOverloads(cancellationToken));
	var rangeKeyBeginsWithAsyncPaged = new Method("Task<ItemPage>", "RangeKeyBeginsWithAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyBeginsWithPaged = new Method("ItemPage", "RangeKeyBeginsWith",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyEqualsAsyncPaged = new Method("Task<ItemPage>", "RangeKeyEqualsAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyEqualsPaged = new Method("ItemPage", "RangeKeyEquals",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanAsyncPaged = new Method("Task<ItemPage>", "RangeKeyLessThanAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyLessThanPaged = new Method("ItemPage", "RangeKeyLessThan",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyLessThanOrEqualToAsyncPaged = new Method("Task<ItemPage>", "RangeKeyLessThanOrEqualToAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyLessThanOrEqualToPaged = new Method("ItemPage", "RangeKeyLessThanOrEqualTo",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanAsyncPaged = new Method("Task<ItemPage>", "RangeKeyGreaterThanAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyGreaterThanPaged = new Method("ItemPage", "RangeKeyGreaterThan",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyGreaterThanOrEqualToAsyncPaged = new Method("Task<ItemPage>", "RangeKeyGreaterThanOrEqualToAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var rangeKeyGreaterThanOrEqualToPaged = new Method("ItemPage", "RangeKeyGreaterThanOrEqualTo",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var rangeKeyBetweenAsyncPaged = new Method("Task<ItemPage>", "RangeKeyBetweenAsync",
		Parameters.GenOverloads(false, rangeKeyBetweenOverloads, cancellationToken));
	var rangeKeyBetweenPaged = new Method("ItemPage", "RangeKeyBetween",
		Parameters.GenOverloads(false, rangeKeyBetweenOverloads));

	// Query Count Range
	var countAllKeysAsync = new Method("Task<int>", "AllKeysAsync", Parameters.GenOverloads(cancellationToken));
	var countRangeKeyBeginsWithAsync = new Method("Task<int>", "RangeKeyBeginsWithAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var countRangeKeyBeginsWith = new Method("int", "RangeKeyBeginsWith",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var countRangeKeyEqualsAsync = new Method("Task<int>", "RangeKeyEqualsAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var countRangeKeyEquals = new Method("int", "RangeKeyEquals",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var countRangeKeyLessThanAsync = new Method("Task<int>", "RangeKeyLessThanAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var countRangeKeyLessThan = new Method("int", "RangeKeyLessThan",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var countRangeKeyLessThanOrEqualToAsync = new Method("Task<int>", "RangeKeyLessThanOrEqualToAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var countRangeKeyLessThanOrEqualTo = new Method("int", "RangeKeyLessThanOrEqualTo",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var countRangeKeyGreaterThanAsync = new Method("Task<int>", "RangeKeyGreaterThanAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var countRangeKeyGreaterThan = new Method("int", "RangeKeyGreaterThan",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var countRangeKeyGreaterThanOrEqualToAsync = new Method("Task<int>", "RangeKeyGreaterThanOrEqualToAsync",
		Parameters.GenOverloads(false, rangeKeyOverloads, cancellationToken));
	var countRangeKeyGreaterThanOrEqualTo = new Method("int", "RangeKeyGreaterThanOrEqualTo",
		Parameters.GenOverloads(false, rangeKeyOverloads));
	var countRangeKeyBetweenAsync = new Method("Task<int>", "RangeKeyBetweenAsync",
		Parameters.GenOverloads(false, rangeKeyBetweenOverloads, cancellationToken));
	var countRangeKeyBetween = new Method("int", "RangeKeyBetween",
		Parameters.GenOverloads(false, rangeKeyBetweenOverloads));

	// Scan Options Paged
	var scanAllAsyncPaged = new Method("Task<ItemPage>", "AllAsync", Parameters.GenOverloads(cancellationToken));
	var scanSegmentAsyncPaged = new Method("Task<ItemPage>", "SegmentAsync", Parameters.GenOverloads(segment, totalSegments, cancellationToken));
#>
using Adamantworks.Amazon.DynamoDB.Contexts;
using Adamantworks.Amazon.DynamoDB.Converters;
using Adamantworks.Amazon.DynamoDB.DynamoDBValues;
using Adamantworks.Amazon.DynamoDB.Schema;
using Adamantworks.Amazon.DynamoDB.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Adamantworks.Amazon.DynamoDB
{
	public partial interface IDynamoDBRegion
	{
<#=		listTablesAsync.GenInterface() #>

<#=		listTablesWithPrefixAsync.GenInterface() #>

<#=		createTableAsync.GenInterface() #>
<#=		createTable.GenInterface() #>
	}

	internal partial class Region
	{
<#=		listTablesAsync.GenMethods() #>

<#=		listTablesWithPrefixAsync.GenMethods() #>

<#=		createTableAsync.GenMethods() #>

<#=		createTable.GenMethods() #>
	}

	public partial interface ITable
	{
<#=		reloadAsync.GenInterface() #>

<#=		waitUntilNotAsync.GenInterface() #>

<#=		updateTableAsync.GenInterface() #>
<#=		updateTable.GenInterface() #>

<#=		forKey.GenInterface() #>

<#=		batchDeleteAsync.GenInterface() #>
<#=		batchDelete.GenInterface() #>
	}

	internal partial class Table
	{
<#=		reloadAsync.GenMethods() #>

<#=		waitUntilNotAsync.GenMethods() #>

<#=		updateTableAsync.GenMethods() #>

<#=		updateTable.GenMethods() #>

<#=		getAsyncForwards.GenMethods() #>

<#=		getForwards.GenMethods() #>

<#=		batchGetAsyncForwards.GenMethods() #>

<#=		batchGetForwards.GenMethods() #>

<#=		batchGetJoinAsyncForwards.GenMethods() #>

<#=		batchGetJoinForwards.GenMethods() #>

<#=		forKey.GenMethods() #>

<#=		putAsyncForwards.GenMethods() #>

<#=		putForwards.GenMethods() #>

<#=		queryForwards.GenMethods() #>

<#=		queryCountForwards.GenMethods() #>

<#=		scanForwards.GenMethods() #>

<#=		batchDeleteAsync.GenMethods() #>

<#=		batchDelete.GenMethods() #>
	}

	internal partial class Index
	{
<#=		indexQueryForwards.GenMethods() #>

<#=		indexQueryCountForwards.GenMethods() #>

<#=		indexScanForwards.GenMethods() #>
	}
}

namespace Adamantworks.Amazon.DynamoDB.Syntax
{
	public partial interface IGetSyntax
	{
<#=		getAsync.GenInterface() #>
<#=		get.GenInterface() #>

<#=		batchGetAsync.GenInterface() #>
<#=		batchGet.GenInterface() #>

<#=		batchGetJoinAsync.GenInterface() #>
<#=		batchGetJoin.GenInterface() #>
	}

	public partial interface IModifySyntax
	{
<#=		updateAsync.GenInterface() #>
<#=		update.GenInterface() #>

<#=		deleteAsync.GenInterface() #>
<#=		delete.GenInterface() #>
	}

	public partial interface IPagedQueryRangeSyntax
	{
<#=		allKeysAsyncPaged.GenInterface() #>

<#=		rangeKeyBeginsWithAsyncPaged.GenInterface() #>
<#=		rangeKeyBeginsWithPaged.GenInterface() #>

<#=		rangeKeyEqualsAsyncPaged.GenInterface() #>
<#=		rangeKeyEqualsPaged.GenInterface() #>

<#=		rangeKeyLessThanAsyncPaged.GenInterface() #>
<#=		rangeKeyLessThanPaged.GenInterface() #>

<#=		rangeKeyLessThanOrEqualToAsyncPaged.GenInterface() #>
<#=		rangeKeyLessThanOrEqualToPaged.GenInterface() #>

<#=		rangeKeyGreaterThanAsyncPaged.GenInterface() #>
<#=		rangeKeyGreaterThanPaged.GenInterface() #>

<#=		rangeKeyGreaterThanOrEqualToAsyncPaged.GenInterface() #>
<#=		rangeKeyGreaterThanOrEqualToPaged.GenInterface() #>

<#=		rangeKeyBetweenAsyncPaged.GenInterface() #>
<#=		rangeKeyBetweenPaged.GenInterface() #>
	}

	public partial interface IPagedScanOptionsSyntax
	{
<#=		scanAllAsyncPaged.GenInterface() #>

<#=		scanSegmentAsyncPaged.GenInterface() #>
	}

	public partial interface IPutSyntax
	{
<#=		putAsync.GenInterface() #>
<#=		put.GenInterface() #>
	}

	public partial interface IQueryCountRangeSyntax
	{
<#=		countAllKeysAsync.GenInterface() #>

<#=		countRangeKeyBeginsWithAsync.GenInterface() #>
<#=		countRangeKeyBeginsWith.GenInterface() #>

<#=		countRangeKeyEqualsAsync.GenInterface() #>
<#=		countRangeKeyEquals.GenInterface() #>

<#=		countRangeKeyLessThanAsync.GenInterface() #>
<#=		countRangeKeyLessThan.GenInterface() #>

<#=		countRangeKeyLessThanOrEqualToAsync.GenInterface() #>
<#=		countRangeKeyLessThanOrEqualTo.GenInterface() #>

<#=		countRangeKeyGreaterThanAsync.GenInterface() #>
<#=		countRangeKeyGreaterThan.GenInterface() #>

<#=		countRangeKeyGreaterThanOrEqualToAsync.GenInterface() #>
<#=		countRangeKeyGreaterThanOrEqualTo.GenInterface() #>

<#=		countRangeKeyBetweenAsync.GenInterface() #>
<#=		countRangeKeyBetween.GenInterface() #>
	}

	public partial interface IQueryRangeSyntax
	{
<#=		allKeysAsync.GenInterface() #>

<#=		rangeKeyBeginsWithAsync.GenInterface() #>
<#=		rangeKeyBeginsWith.GenInterface() #>

<#=		rangeKeyEqualsAsync.GenInterface() #>
<#=		rangeKeyEquals.GenInterface() #>

<#=		rangeKeyLessThanAsync.GenInterface() #>
<#=		rangeKeyLessThan.GenInterface() #>

<#=		rangeKeyLessThanOrEqualToAsync.GenInterface() #>
<#=		rangeKeyLessThanOrEqualTo.GenInterface() #>

<#=		rangeKeyGreaterThanAsync.GenInterface() #>
<#=		rangeKeyGreaterThan.GenInterface() #>

<#=		rangeKeyGreaterThanOrEqualToAsync.GenInterface() #>
<#=		rangeKeyGreaterThanOrEqualTo.GenInterface() #>

<#=		rangeKeyBetweenAsync.GenInterface() #>
<#=		rangeKeyBetween.GenInterface() #>
	}

	public partial interface IQuerySyntax
	{
<#=		query.GenInterface() #>

<#=		queryCount.GenInterface() #>
	}

	public partial interface IScanOptionsSyntax
	{
<#=		scanAllAsync.GenInterface() #>

<#=		scanSegmentAsync.GenInterface() #>
	}

	public partial interface IScanSyntax
	{
<#=		scan.GenInterface() #>
	}

	public partial interface ITryModifySyntax
	{
<#=		tryUpdateAsync.GenInterface() #>
<#=		tryUpdate.GenInterface() #>
	}
}

namespace Adamantworks.Amazon.DynamoDB.Contexts
{
	internal partial class GetContext
	{
<#=		getAsync.GenMethods() #>

<#=		get.GenMethods() #>

<#=		batchGetAsync.GenMethods() #>

<#=		batchGet.GenMethods() #>

<#=		batchGetJoinAsync.GenMethods() #>

<#=		batchGetJoin.GenMethods() #>

<#=		query.GenMethods() #>

<#=		queryCount.GenMethods() #>

<#=		scan.GenMethods() #>
	}

	internal partial class IndexContext
	{
<#=		indexQuery.GenMethods() #>

<#=		indexQueryCount.GenMethods() #>

<#=		indexScan.GenMethods() #>
	}

	internal partial class ModifyContext
	{
<#=		updateAsync.GenMethods() #>

<#=		update.GenMethods() #>

<#=		tryUpdateAsync.GenMethods() #>

<#=		tryUpdate.GenMethods() #>

<#=		deleteAsync.GenMethods() #>

<#=		delete.GenMethods() #>
	}

	internal partial class PutContext
	{
<#=		putAsync.GenMethods() #>

<#=		put.GenMethods() #>
	}

	internal partial class QueryContext
	{
<#=		allKeysAsync.GenMethods() #>

<#=		rangeKeyBeginsWithAsync.GenMethods() #>

<#=		rangeKeyBeginsWith.GenMethods() #>

<#=		rangeKeyEqualsAsync.GenMethods() #>

<#=		rangeKeyEquals.GenMethods() #>

<#=		rangeKeyLessThanAsync.GenMethods() #>

<#=		rangeKeyLessThan.GenMethods() #>

<#=		rangeKeyLessThanOrEqualToAsync.GenMethods() #>

<#=		rangeKeyLessThanOrEqualTo.GenMethods() #>

<#=		rangeKeyGreaterThanAsync.GenMethods() #>

<#=		rangeKeyGreaterThan.GenMethods() #>

<#=		rangeKeyGreaterThanOrEqualToAsync.GenMethods() #>

<#=		rangeKeyGreaterThanOrEqualTo.GenMethods() #>

<#=		rangeKeyBetweenAsync.GenMethods() #>

<#=		rangeKeyBetween.GenMethods() #>

<#=		allKeysAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyBeginsWithAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyBeginsWithPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyEqualsAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyEqualsPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyLessThanAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyLessThanPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyLessThanOrEqualToAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyLessThanOrEqualToPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyGreaterThanAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyGreaterThanPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyGreaterThanOrEqualToAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyGreaterThanOrEqualToPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyBetweenAsyncPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>

<#=		rangeKeyBetweenPaged.GenExplicitImplementations("IPagedQueryRangeSyntax") #>
	}

	internal partial class QueryCountContext
	{
<#=		countAllKeysAsync.GenMethods() #>

<#=		countRangeKeyBeginsWithAsync.GenMethods() #>

<#=		countRangeKeyBeginsWith.GenMethods() #>

<#=		countRangeKeyEqualsAsync.GenMethods() #>

<#=		countRangeKeyEquals.GenMethods() #>

<#=		countRangeKeyLessThanAsync.GenMethods() #>

<#=		countRangeKeyLessThan.GenMethods() #>

<#=		countRangeKeyLessThanOrEqualToAsync.GenMethods() #>

<#=		countRangeKeyLessThanOrEqualTo.GenMethods() #>

<#=		countRangeKeyGreaterThanAsync.GenMethods() #>

<#=		countRangeKeyGreaterThan.GenMethods() #>

<#=		countRangeKeyGreaterThanOrEqualToAsync.GenMethods() #>

<#=		countRangeKeyGreaterThanOrEqualTo.GenMethods() #>

<#=		countRangeKeyBetweenAsync.GenMethods() #>

<#=		countRangeKeyBetween.GenMethods() #>
	}

	internal partial class ScanContext
	{
<#=		scanAllAsync.GenMethods() #>

<#=		scanAllAsyncPaged.GenExplicitImplementations("IPagedScanOptionsSyntax") #>

<#=		scanSegmentAsync.GenMethods() #>

<#=		scanSegmentAsyncPaged.GenExplicitImplementations("IPagedScanOptionsSyntax") #>
	}
}
